{****************************
** Switcharoo v1.0.4 - by Hushaboom **
**Fast Zone switching tool for Kontakt**
**Offers sample switching on the fly while maintaining full Velo Range.**
**Developed By:  Sultry Sound**
**Producer:	Steve Sechler**
**Programmed by:	Robert Kerr**


Copyright [2023] [SultrySound, LLC]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

****************************
}


on init

	{
	Init needs to:
	-declare variables
	-configure the listener
	-Count and arrange groups - maybe
	-build the list in this format:  key/value - [groups](Zones)  
	}
	
	
	load_performance_view("perf.nckp")
	message("Hello SultrySounds!")
	
	{Real numbers/Float Variables}
	declare ~threshold := 0.0
	declare ~messages := 0.0

	{Switches}
	declare $endZone
	declare $outcast
	declare $onGroup
	
	{String Variables}
	declare @robin_status
	
	{Integers}
	declare $groupCount := 0
	declare $onInit := 0
	
	{Group Keys}
	declare $group0 := 0
	declare $group1 := 1
	declare $group2 := 2
	declare $group3 := 3
	declare $group4 := 4
	
	{
	Arrays (starting with 5 'voices' in the pool. trying to list the group/zone id as tuples)
	this is experiment.  may not need it.  may not work.  
	}
	declare %pool[5] := (0,1,2,3,4)
	
	{Index Groups}
	while ($groupCount < $NUM_GROUPS)
		$groupCount := $groupCount + 1
		end while
		
	{Listener Config}
	set_listener($NI_SIGNAL_TIMER_MS,500000)	{Kontakt reads time in microseconds, not miliseconds}
	
end on




{	For reference, i always say padstrike, keystrike, or hit 
	(strike the pad or key on the midi controler).
	So by hit I means, on note..
	Update.  I educated myself.  The correct terminology is Midi Message
	now i know
	}
	
on note

{Update  06/14/23 16:13  -  Cycles between 5 groups based on conditions.  Once again out of control, but we can dial it in.}
{Update: 06/14/23 17:39  -  All conditions need to be rewritten, but the theory is there}

~messages := ~messages + 0.5
disallow_group($ALL_GROUPS) {Silence all layers}

if ($onInit = 0)

	$onInit := 1	
	$onGroup := $group0
	message("Init was recognized")
	allow_group($onGroup)
	
end if

if ($outcast = $group0)

	disallow_group($ALL_GROUPS)
	$outcast := 9999
	$onGroup := $group1
	allow_group($onGroup)
	
end if
	
if ($outcast = $group1)

	disallow_group($ALL_GROUPS)
	$outcast := 9999
	$onGroup := $group2
	allow_group($onGroup)
	
end if

if ($outcast = $group2)

	disallow_group($ALL_GROUPS)
	$outcast := 9999
	$onGroup := $group3
	allow_group($onGroup)
	
end if

if ($outcast = $group3)

	disallow_group($ALL_GROUPS)
	$outcast := 9999
	$onGroup := $group4
	allow_group($onGroup)
	
end if

if ($outcast = $group4)

	disallow_group($ALL_GROUPS)
	$outcast := 9999
	$onGroup := $group0
	allow_group($onGroup)
	
end if

allow_group($onGroup)

end on



on release

~messages := ~messages + 0.5

end on



on listener

{Starting with the time delay on 1.0.4  06/14/23 09:45
Update 06/14/23 12:14  -  it is switching, but still lacking control.  But confirmed, time-delay works as predicted
I have the preset at 1/2 second because I'm using a mouse.  It is switching seamlessly now
}

{Update:  06/14/23 14:11  -  we now have full control of our time delay}
{Update:  60/14/23 16:15  -  Time ticks here in the listener.  So we are switching the active group variable here.
The on note callback will recognize the change, and initiate the switch in the player.}
{Note:  We can also initiate the switch with the on release callback, and a few others I think.
worth looking into.
This gives us a lot of flexibility when deciding our conditions for making any changes, not just in time
}

if (~messages > 1.5)

	$onGroup := $group1
	$outcast := $group0
	message("On group 1, Group0 outcast")
	
else

	$onGroup := $group0
	$outcast := 9999
	message("On Group0, no outcast")
	
end if

if ((~messages > 2.0) and ($outcast = $group0))

	$onGroup := $group2
	$outcast := $group1
	message("On Group2, Group1 outcast")
	
else
	
	$onGroup := $group0
	$outcast := 9999
	message("On Group0, no outcast")
	~messages := 0.0
	
end if

if ((~messages > 2.0) and ($outcast = $group1))

	$onGroup := $group3
	$outcast := $group2
	message("On Group3, Group2 outcast")
	~messages := 0.0
	
else
	
	$onGroup := $group0
	$outcast := 9999
	message("On Group0, no outcast")
	~messages := 0.0
	
end if

if ((~messages > 2.5) and ($outcast = $group2))

	$onGroup := $group4
	$outcast := $group3
	message("On Group4, Group3 outcast")
	~messages := 0.0
	
else
	
	$onGroup := $group0
	$outcast := 9999
	message("On Group0, no outcast")
	~messages := 0.0
	
end if

if ((~messages = 0.0) and ($outcast = $group3))

	$onGroup := $group3
	$outcast := $group4
	message("On Group3, Group4 outcast")
	~messages := 0.0
	
else

	if (~messages > 1.5)
		
		if ($outcast = $group3)
			
			$onGroup := $group1
			$outcast := $Group4
			message("On Group1, Group4 outcast")
			
			~messages := 0.0
			
		end if
		
	end if
	
	$onGroup := $group0
	$outcast := 9999
	message("On Group0, no outcast")
	~messages := 0.0
	
end if

~messages := 0.0

end on